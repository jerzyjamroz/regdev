<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>RegDev EPICS Device Support</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="author" content="Dirk Zimoch">
<style type="text/css">
<!--
.indent {text-indent:-4ex; margin-left:4ex; text-align:left;}
@media screen {
pre,code {color:green; }
}
@media print {
a {color:black; text-decoration:none; }
}
-->
</style>
</head>
<body>
<h1><em>RegDev</em> EPICS Device Support Documentation</h1>
<h2>Contents</h2>
<ol>
<li><a href="#device">Device Support</a>
 <ol>
 <li><a href="#stat">Connection Status</a></li>
 <li><a href="#ai">Analog Input</a></li>
 <li><a href="#ao">Analog Output</a></li>
 <li><a href="#bi">Binary Input</a></li>
 <li><a href="#bo">Binary Output</a></li>
 <li><a href="#mbbi">Multibit Binary Input</a></li>
 <li><a href="#mbbo">Multibit Binary Output</a></li>
 <li><a href="#mbbiDirect">Multibit Binary Input Direct</a></li>
 <li><a href="#mbboDirect">Multibit Binary Output Direct</a></li>
 <li><a href="#longin">Long Input</a></li>
 <li><a href="#longout">Long Output</a></li>
 <li><a href="#stringin">String Input</a></li>
 <li><a href="#stringout">String Output</a></li>
 <li><a href="#waveform">Waveform Input</a></li>
 <li><a href="#calcout">Calculation Output</a></li>
 </ol></li>
<li><a href="#driver">Driver Functions</a></li>
<li><a href="#debugging">Debugging</a></li>
</ol>
<h2>Intro</h2>
<p>
In this document, I assume that the reader is familiar with EPICS, the
record concept and meanings of the fields of the standard records.
Recommended reading: EPICS Record Reference Manual.
</p>
<p>
This generic device support is intended to connect arbitrary synchronous
register based devices to EPICS in a simple and flexible way.
It can be used for rapid prototyping before a proper driver is available,
to access registers that are unsupported by the proper driver or as the
ultimate driver for any device which is "simple enough".
</p>
<p>
It is assumed that the device allocates a continuous block of registers.
The registers should be independent, that means one device action is
performed by reading or writing only one register.
Because each record connects to one register, it is not possible to lock
the device for several register accesses with this device support,
except if that task is performed in the low level driver and hidden from
<em>regDev</em>.
The user has to know the register offsets and data types when configuring
the records.
</p>
<p>
The actual hardware access is neither defined nor implemented in this
device support.
Instead, <em>regDev</em> defines an interface for low level drivers that
implement the hardware access.
Examples are <em>mmap</em> (a driver for memory mapped registers, VME or
mmap()) or <em>s7plc</em> (a driver for network communication to a Siemens
S7 PLC).
What is defined in <em>regDev</em> is the interface to the standard
records.
Thus it is not necessary to deal with record when writing a new low-level
driver.
Consequently, all <em>regDev</em> compatible devices look the same
on the record level.
The general idea is to have a simple and flexible device support interface
which is independent of the underlying hardware structure.
</p>
<p>
To be usable with <em>regDev</em>, a driver must implement some API
functions and register a device to <em>regDev</em> by name.
Each piece of <em>regDev</em> hardware must have a name that is unique on
the IOC.
Typically, the low level driver registers a device in a configuration
function called from the startup script.
</p>
<p>
In principle, a piece of hardware can have many blocks of registers
(e.g. on differenct VME address spaces).
The low level driver may handle this by mapping ranges of register offsets
to different blocks.
Or the low level driver registers each block with an individual name. 
But then, <em>regDev</em> will handle them as different independent
devices.
</p>
<p>
A demo driver is included.
</p>
<p>
<a href="mailto:Dirk Zimoch <dirk.zimoch&#64;psi&#46;ch>">Dirk
Zimoch &lt;dirk.zimoch&#64;psi&#46;ch&gt;</a>, 2009.
</p>


<a name="device"></a>
<h2>Device Support</h2>
<p>
<em>RegDev</em> supports the standard record types <a href="#ai">ai</a>,
<a href="#ao">ao</a>,
<a href="#bi">bi</a>,
<a href="#bo">bo</a>,
<a href="#mbbi">mbbi</a>,
<a href="#mbbo">mbbo</a>,
<a href="#mbbiDirect">mbbiDirect</a>,
<a href="#mbboDirect">mbboDirect</a>,
<a href="#longin">longin</a>,
<a href="#longout">longout</a>,
<a href="#stringin">stringin</a>,
<a href="#stringout">stringout</a>,
and <a href="#waveform">waveform</a>.
With EPICS R3.14, <a href="#calcout">calcout</a> is supported, too.
When compiled with the macro <code>WITH_AAIO</code> defined,
<a href="#aai">aai</a> and <a href="#aao">aao</a> records are supported,
too.
These records are part of EPICS base but unsupported and usually commented
out.
</p>
<p>
The <code>DTYP</code> is <code>"regDev"</code> for all record types,
independent of the low level driver.
</p>
<p>
If a record processes when the device is not connected (off, down,
unreachable), the record raises an alarm with <code>SEVR="INVALID"</code>
and <code>STAT="READ"</code> or <code>"WRITE"</code>
</p>
<p>
There is also a connection status support for <a href="#stat">bi</a>. The
<code>DTYP</code> is <code>"regDev&nbsp;stat"</code>. This record does not
raise an alarm when the device is disconnected. It just changes to
<code>0</code> when the device disconencts and to 1 when it connects.
</p>
<p>
It is possible to use <code>SCAN="I/O Intr"</code> if the low level driver
supports it.
Input records in <code>"I/O Intr"</code> process whenever new data has
been received from the device.
If supported by the driver, output records are processed in
<code>"I/O Intr"</code> mode whenever the driver is ready to accept new
output.
This may be useful for drivers with externally triggered or periodic
output cycles.
</p>
<p class="indent">
The general form of the <code>INP</code> or <code>OUT</code> link is:<br>
<code>
  "@<i>devicename</i>:<i>offset</i>:<i>initoffset</i> T=<i>type</i>
  L=<i>low</i> H=<i>high</i> B=<i>bit</i> I=<i>invertmask</i>
  P=<i>packing</i>"
</code>
</p>
<ul>
<li>
<code><i>devicename</i></code> is the name that a low level driver has
used to register the device.
</li>
<li>
<code><i>offset</i></code> is the address of the register relative to the
beginning of the register block for this device. 
It depends on the low level driver if offset is measured in bytes 
or anything else.
The offset must be a positive integer expression.
It may include the operators <code>+-*()</code>.
</li>
<li>
<code><i>initoffset</i></code> is optionally used by output records to
initialize from a hardware register.
If <code><i>initoffset</i></code> is not specified but the second
<code>:</code> is there, the record initializes from the normal
<code><i>offset</i></code> address.
If <code>:<i>initoffset</i></code> is skipped (including the
<code>:</code>),
the record is not initialized by <em>regDev</em> and may be initialized
for example by auto save and restore.
Records read from <code><i>initoffset</i></code> during the
<code>init_record</code> phase in unpredictable order.
</li>
<li>
<code>T=<i>type</i></code> defines the data type of the register.
See <a href="#type">table below</a>.
The default is <code>T=int16</code> for most record types.
</li>
<li>
<code>L=<i>low</i></code> and <code>H=<i>high</i></code> are used for
linear conversion in <a href="ai">ai</a> and <a href="ao">ao</a> records
if <code>LINR="LINEAR"</code>.
They define the raw values which correspond to <code>EGUL</code> and
<code>EGUF</code>, respectively.
Analog output records will never write raw values lower than
<code>L</code> or higher than <code>H</code>.
If necessary, the raw output value is truncated to the nearest limit.
The default values for
<code>L</code> and <code>H</code> depend on the data type.
</li>
<li>
<code>B=<i>bit</i></code> is only used for <a href="#bi">bi</a> and
<a href="#bo">bo</a> records to define the bit number within the data
byte, word, or doubleword (depending on <code>T</code>).
Bit number 0 is the least significant bit.
Note that in big endian byte order (also known as motorola format) bit 0
is in the last byte, while in little endian byte order (intel format)
bit 0 is in the first byte.
If in doubt, use <code>T=byte</code> to avoid all byte order problems
when handling single bits.
</li>
<li>
<code>I=<i>invertmask</i></code> is used to flip bits of integer values
before writing them to or after reading them from a register.
This allows to invert the logic of bits.
The default value is 0 (i.e. do not flip bits).
</li>
<li>
<code>P=<i>packing</i></code> is used for accessing arrays through
FIFO registers.
It defines how many array elements are packed in one register access.
For example <code>T=int16 P=1</code> defines a FIFO of 16 bit values
while <code>T=int16 P=2</code> is a FIFO with 32 bits width that
contains two 16 bit values in each access.
</li>
</ul>
<p>
Not all parameters <code>T</code>, <code>L</code>, <code>H</code>,
<code>B</code>, <code>I</code>, and <code>P</code> are always
required.
Unused parameters or parameters equal to the default value may be omitted.
The default values depend on the data type.
All parameters are case insensitive.
</p>
<a name="type"></a>
<center>
<table border=1 cellpadding=5>
<tr>
 <th>T=</th>
 <th>Register Data Type</th>
 <th>Default L=</th>
 <th>Default H=</th>
</tr>
<tr>
 <td><tt>int8</tt>
 </td><td>8 bit (1 byte) signed integer number</td>
 <td><tt>-0x7f<br>-127</tt></td>
 <td><tt>0x7f<br>127</tt></td>
</tr>
<tr>
 <td><tt>uint8<br>unsign8<br>unsigned8<br>byte<br>char</tt>
 </td><td>8 bit (1 byte) unsigned integer number</td>
 <td><tt>0x00<br>0</tt></td>
 <td><tt>0xff<br>255</tt></td>
</tr>
<tr>
 <td><tt>int16<br>short</tt></td>
 <td>16 bit (2 bytes) signed integer number</td>
 <td><tt>-0x7fff<br>-32767</tt></td>
 <td><tt>0x7fff<br>32767</tt></td>
</tr>
<tr>
 <td><tt>uint16<br>unsign16<br>unsigned16<br>word</tt></td>
 <td>16 bit (2 bytes) unsigned integer number</td>
 <td><tt>0x0000<br>0</tt></td>
 <td><tt>0xffff<br>65535</tt></td>
</tr>
<tr>
 <td><tt>int32<br>long</tt></td>
 <td>32 bit (4 bytes) signed integer number</td>
 <td><tt>-0x7fffffff<br>-2147483647</tt></td>
 <td><tt>0x7fffffff<br>2147483647</tt></td>
</tr>
<tr>
 <td><tt>uint32<br>unsign32<br>unsigned32<br>dword</tt></td>
 <td>32 bit (4 bytes) unsigned integer number</td>
 <td><tt>0x00000000<br>0</tt></td>
 <td><tt>0xffffffff<br>4294967295</tt></td>
</tr>
<tr>
 <td><tt>bcd8<br>bcd</tt>
 </td><td>8 bit (1 byte, 2 digits) unsigned binary coded decimal</td>
 <td><tt>00</tt></td>
 <td><tt>99</tt></td>
</tr>
<tr>
 <td><tt>bcd16</tt>
 </td><td>16 bit (2 bytes, 4 digits) unsigned binary coded decimal</td>
 <td><tt>0000</tt></td>
 <td><tt>9999</tt></td>
</tr>
<tr>
 <td><tt>bcd32</tt>
 </td><td>32 bit (4 bytes, 8 digits) unsigned binary coded decimal</td>
 <td><tt>00000000</tt></td>
 <td><tt>99999999</tt></td>
</tr>
<tr>
 <td><tt>real32<br>float32<br>float<br>single</tt></td>
 <td>32 bit (4 bytes) floating point number</td>
 <td>n/a</td><td>n/a</td>
</tr>
<tr>
 <td><tt>real64<br>float64<br>double</tt></td>
 <td>64 bit (8 bytes) floating point number</td>
 <td>n/a</td><td>n/a</td>
</tr>
<tr>
 <td><tt>string</tt></td>
 <td>character array</td>
 <td>40</td><td>n/a</td>
</tr>
</table>
</center>

<p>
If <code>T=string</code>, <code>L</code> means <i>length</i>,
not <i>low</i>.
The length includes the terminating null byte.
The default value is the length of the <code>VAL</code> field.
In the case of the stringin and stringout records, this is 40.
In case of array records (<a href="#aai">aai</a>, <a href="#aao">aao</a>,
<a href="#waveform">waveform</a>) with <code>CHAR</code>
data this is the size of the array (usually <code>NELM</code>).
</p>

<h2>Example Records</h2>
<p>
In the following examples it is assumed that the low level driver supports
<code>"I/O Intr"</code> for input registers.
If that is not the case or not applicable for all registers use any other
scanning method instead.
</p>

<a name="stat"></a>
<h3>Connection Status</h3>
<pre>
 record (bi, "$(RECORDNAME)") {
  field (DTYP, "regDev stat")
  field (INP,  "@$(DEVICE)")
  field (SCAN, "I/O Intr")
 }
</pre>
<p>
The record value is 1 if a connection to the device is established and 0
if not.
Disconnect does not raise an alarm.
</p>

<a name="ai"></a>
<h3>Analog Input</h3>
<h4>Integer registers with linear converion</h4>
<pre>
 record (ai, "$(RECORDNAME)") {
  field (DTYP, "regDev")
  field (INP,  "@$(DEVICE):$(OFFSET) T=$(T) L=$(L) H=$(H)")
  field (SCAN, "I/O Intr")
  field (LINR, "LINEAR")
  field (EGUL, "$(MINVAL)")
  field (EGUF, "$(MAXVAL)")
 }
</pre>
<p>
If <code>T</code> is an integer type, the register is read into
<code>RVAL</code>.
If <code>LINR</code> is set to <code>"LINEAR"</code>, then the record
converts <code>RVAL</code> to <code>VAL</code> so that <code>L</code>
mapps to <code>MINVAL</code> and <code>H</code> to <code>MAXVAL</code>.
</p>
<p>
Default type is <code>T=int16</code>.
Defaults for <code>L</code> and <code>H</code> depend
on <code>T</code> (see table <a href="#type">above</a>).
</p>
<h4>Floating point registers</h4>
<p>
</p>
<pre>
 record (ai, "$(RECORDNAME)") {
  field (DTYP, "regDev")
  field (INP,  "@$(DEVICE):$(OFFSET) T=$(T)")
  field (SCAN, "I/O Intr")
 }
</pre>
<p>
If <code>T=float</code> or <code>T=double</code>,
the register is read directly into <code>VAL</code> and <code>L</code>,
<code>H</code>, <code>EGUL</code> and <code>EGUF</code> are ignored.
The device support emulates adjustment scaling and smoothing which is done
by the record only when using conversion from integer registers.
</p>
<p>
<code>VAL = (<i>register</i>*ASLO+AOFF)*(1-SMOO) +
VAL<sub>old</sub>*SMOO</code> 
</p>
<p>
<code>T=string</code> is not valid for ai records.
</p>

<a name="ao"></a>
<h3>Analog Output</h3>
<h4>Integer registers with linear converion</h4>
<pre>
 record (ao, "$(RECORDNAME)") {
  field (DTYP, "regDev")
  field (OUT,  "@$(DEVICE):$(OFFSET) T=$(T) L=$(L) H=$(H)")
  field (LINR, "LINEAR")
  field (PINI, "YES")
  field (EGUL, "$(MINVAL)")
  field (EGUF, "$(MAXVAL)")
 }
</pre>
<p>
If <code>T</code> is an integer type, <code>RVAL</code> is written to the
register.
If <code>LINR</code> is set to <code>"LINEAR"</code>, then the record
support first scales the record value (to be exact <code>OVAL</code>) so
that <code>MINVAL</code> mapps to <code>L</code> and <code>MAXVAL</code>
mapps to <code>H</code>.
The record may then use adjustmant scaling to modify <code>RVAL</code>.
However, the device support will never write any value lower than
<code>L</code> or higher than <code>H</code>.
If necessary the value will be truncated to the nearest limit.
</p>
<p>
Default type is <code>T=int16</code>.
Defaults for <code>L</code> and <code>H</code> depend
on <code>T</code> (see table <a href="#type">above</a>).
</p>
<h4>Floating point registers</h4>
<pre>
 record (ao, "$(RECORDNAME)") {
  field (DTYP, "regDev")
  field (OUT,  "@$(DEVICE):$(OFFSET) T=$(T)")
  field (PINI, "YES")
 }
</pre>
<p>
If <code>T=float</code> or <code>T=double</code>,
<code>OVAL</code> is written to the register. <code>L</code>,
<code>H</code>, <code>EGUL</code> and <code>EGUF</code> are ignored.
The device support emulates adjustment scaling which is done by the
record only when converting to integer registers.
</p>
<p>
<code><i>register</i>=(OVAL-AOFF)/ASLO</code>
</p>
<p>
<code>T=string</code> is not valid for ao records.
</p>

<a name="bi"></a>
<h3>Binary Input</h3>
<pre>
 record(bi, "$(NAME)") {
  field (DTYP, "regDev")
  field (INP,  "@$(DEVICE):$(OFFSET) T=$(T) B=$(B) I=$(I)")
  field (SCAN, "I/O Intr")
 }
</pre>
<p>
Default type is <code>T=int16</code>.
Default bit is <code>B=0</code>.
Default invert mask is <code>I=0</code>.
</p>
<p>
Depending on <code>T</code>, <code>B</code> can vary from 0 to 7, 15,
or 31.
Bit 0 is the least significant bit. In little endian byte order, bit 0 is
in the first byte, in big endian byte order it is in the last byte of the
register.
If in doubt, use <code>T=byte</code> to avoid all byte order problems when
handling single bits.
</p>
<p>
The register is read to <code>RVAL</code> and masked with
2<sup><code>B</code></sup>.
If <code>I!=0</code> the bit is inverted.
The record sets <code>VAL</code> to 1 if <code>RVAL</code> is not 0.
</p>
<p>
<code>RVAL=(I==0?<i>register</i>:~<i>register</i>)&(1&lt;&lt;B);
VAL=(RVAL!=0)?1:0</code>
</p>
<p>
<code>T=string</code>, <code>T=float</code> or <code>T=double</code> are
not valid for bo records. Signed and unsigned types are equivalent.
</p>

<a name="bo"></a>
<h3>Binary Output</h3>
<pre>
 record(bo, "$(NAME)") {
  field (DTYP, "regDev")
  field (OUT,  "@$(DEVICE):$(OFFSET) T=$(T) B=<i>$(B)</i>")
  field (PINI, "YES")
 }
</pre>
<p>
Default type is <code>T=int16</code>. Default bit is <code>B=0</code>.
</p>
<p>
Depending on <code>T</code>, <code>B</code> can vary from 0 to 7, 15, or
31.
Bit 0 is the least significant bit.
In little endian byte order, bit 0 is in the first byte, in big endian byte
order it is in the last byte of the register.
If in doubt, use <code>T=byte</code> to avoid all byte order problems when
handling single bits.
</p>
<p>
If <code>VAL</code> is not 0, then <code>RVAL</code> is set to
2<sup><code>B</code></sup>, else <code>RVAL</code> is set to 0.
Only the referenced bit of the register is changed while all other bits
remain untouched.
Thus, other output records can write to different bits of the same
register.
<p>
<code>RVAL=(VAL!=0)?(1&lt;&lt;<i>B</i>):0;
<i>register</i>=(<i>register</i><sub>old</sub>&~(1&lt;&lt;<i>B</i>)) |
RVAL</code>
</p>
<p>
<code>T=string</code>, <code>T=float</code> or <code>T=double</code> are
not valid for bo records. Signed and unsigned types are equivalent.
</p>

<a name="mbbi"></a>
<h3>Multibit Binary Input</h3>
<pre>
 record(mbbi, "$(NAME)") {
  field (DTYP, "regDev")
  field (INP,  "@$(DEVICE):$(OFFSET) T=$(T)")
  field (SCAN, "I/O Intr")
  field (NOBT, "$(NUMBER_OF_BITS)")
  field (SHFT, "$(RIGHT_SHIFT)")
 }
</pre>
<p>
Default type is <code>T=int16</code>.
</p>
<p>
The register is read to <code>RVAL</code>, shifted right by
<code>SHFT</code> bits and masked with <code>NOBT</code> bits.
Valid values for <code>NOBT</code> and <code>SHFT</code> depend on
<code>T</code>:
<code>NOBT</code>+<code>SHFT</code> must not exceed the number of bits of
the type.
</p>
<p>
Bit 0 is the least significant bit.
In little endian byte order, bit 0 is in the first byte, in big endian
byte order it is in the last byte of the register.
</p>
<p>
<b>Example:</b> Use bits 4 to 9 out of 16.
<code>T=int16</code>, <code>NOBT=6</code>, <code>SHFT=4</code>
</p>
<table border=1 cellspacing=0>
 <tr>
  <td>register</td>
  <th bgcolor="#c0c0c0" width="5%">15</th>
  <th bgcolor="#c0c0c0" width="5%">14</th>
  <th bgcolor="#c0c0c0" width="5%">13</th>
  <th bgcolor="#c0c0c0" width="5%">12</th>
  <th bgcolor="#c0c0c0" width="5%">11</th>
  <th bgcolor="#c0c0c0" width="5%">10</th>
  <th width="5%">9</th>
  <th width="5%">8</th>
  <th width="5%">7</th>
  <th width="5%">6</th>
  <th width="5%">5</th>
  <th width="5%">4</th>
  <th bgcolor="#c0c0c0" width="5%">3</th>
  <th bgcolor="#c0c0c0" width="5%">2</th>
  <th bgcolor="#c0c0c0" width="5%">1</th>
  <th bgcolor="#c0c0c0" width="5%">0</th>
 </tr>
 <tr>
  <td>RVAL</td>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th>9</th>
  <th>8</th>
  <th>7</th>
  <th>6</th>
  <th>5</th>
  <th>4</th>
 </tr>
</table>
<p>
<code>T=string</code>, <code>T=float</code> or <code>T=double</code> are
not valid for mbbi records. Signed and unsigned types are equivalent.
</p>

<a name="mbbo"></a>
<h3>Multibit Binary Output</h3>
<pre>
 record(mbbo, "$(NAME)") {
  field (DTYP, "regDev")
  field (OUT,  "@$(DEVICE):$(OFFSET) T=$(T)")
  field (PINI, "YES")
  field (NOBT, "$(NUMBER_OF_BITS)")
  field (SHFT, "$(LEFT_SHIFT)")
 }
</pre>
<p>
Default type is <code>T=int16</code>.
</p>
<p>
RVAL is masked with <code>NOBT</code> bits, shifted left by
<code>SHFT</code> bits and written to the register. Valid values for
<code>NOBT</code> and <code>SHFT</code> depend on <code>T</code>:
<code>NOBT</code>+<code>SHFT</code> must not exceed the number of bits of
the type.
</p>
<p>
Bit 0 is the least significant bit.
In little endian byte order, bit 0 is in the first byte, in big endian
byte order it is in the last byte of the register.
</p>
<p>
Only the referenced <code>NOBT</code> bits of the register are changed.
All other bits remain untouched.
Thus, other output records can write to different bits of the same
register.
</p>
<p>
<b>Example:</b> Use bits 5 to 8 out of 16.
<code>T=int16</code>, <code>NOBT=4</code>, <code>SHFT=5</code>
</p>
<table border=1 cellspacing=0>
 <tr>
  <td>RVAL</td>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th bgcolor="#c0c0c0">&nbsp;</th>
  <th>8</th>
  <th>7</th>
  <th>6</th>
  <th>5</th>
 </tr>
 <tr>
  <td>register</td>
  <th bgcolor="#c0c0c0" width="5%">15</th>
  <th bgcolor="#c0c0c0" width="5%">14</th>
  <th bgcolor="#c0c0c0" width="5%">13</th>
  <th bgcolor="#c0c0c0" width="5%">12</th>
  <th bgcolor="#c0c0c0" width="5%">11</th>
  <th bgcolor="#c0c0c0" width="5%">10</th>
  <th bgcolor="#c0c0c0" width="5%">9</th>
  <th width="5%">8</th>
  <th width="5%">7</th>
  <th width="5%">6</th>
  <th width="5%">5</th>
  <th bgcolor="#c0c0c0" width="5%">4</th>
  <th bgcolor="#c0c0c0" width="5%">3</th>
  <th bgcolor="#c0c0c0" width="5%">2</th>
  <th bgcolor="#c0c0c0" width="5%">1</th>
  <th bgcolor="#c0c0c0" width="5%">0</th>
 </tr>
</table>
<p>
<code>T=string</code>, <code>T=float</code> or <code>T=double</code> are
not valid for mbbo records. Signed and unsigned types are equivalent.
</p>

<a name="mbbiDirect"></a>
<h3>Multibit Binary Input Direct</h3>
<pre>
 record(mbbiDirect, "$(NAME)") {
  field (DTYP, "regDev")
  field (INP,  "@$(DEVICE):$(OFFSET) T=$(T)")
  field (SCAN, "I/O Intr")
  field (NOBT, "$(NUMBER_OF_BITS)")
  field (SHFT, "$(RIGHT_SHIFT)")
 }
</pre>
<p>
Default type is <code>T=int16</code>.
</p>
<p>
The register is read to <code>VAL</code>, shifted right by
<code>SHFT</code> bits and masked with <code>NOBT</code> bits (see
<a href="#mbbi">mbbi</a>).
Valid values for <code>NOBT</code> and <code>SHFT</code> depend on
<code>T</code>:
<code>NOBT</code>+<code>SHFT</code> must not exceed the number of bits of
the type.
</p>
<p>
Bit 0 is the least significant bit.
In little endian byte order, bit 0 is in the first byte, in big endian
byte order it is in the last byte of the register.
</p>
<p>
<code>T=string</code>, <code>T=float</code> or <code>T=double</code> are
not valid for mbbiDirect records. Signed and unsigned types are equivalent.
</p>

<a name="mbboDirect"></a>
<h3>Multibit Binary Output Direct</h3>
<pre>
 record(mbboDirect, "$(NAME)") {
  field (DTYP, "regDev")
  field (OUT,  "@$(DEVICE):$(OFFSET) T=$(T)")
  field (PINI, "YES")
  field (NOBT, "$(NUMBER_OF_BITS)")
  field (SHFT, "$(LEFT_SHIFT)")
 }
</pre>
<p>
Default type is <code>T=int16</code>.
</p>
<p>
VAL is masked with <code>NOBT</code> bits, shifted left by
<code>SHFT</code> bits and written to the register (see
<a href="#mbbo">mbbo</a>).
Valid values for <code>NOBT</code> and <code>SHFT</code> depend on
<code>T</code>:
<code>NOBT</code>+<code>SHFT</code> must not exceed the number of bits of
the type.
</p>
<p>
Bit 0 is the least significant bit.
In little endian byte order, bit 0 is in the first byte, in big endian
byte order it is in the last byte of the register.
</p>
<p>
Only the referenced <code>NOBT</code> bits of the register are changed.
All other bits remain untouched. Thus, other output records can write to
different bits of the same register.
</p>
<p>
<code>T=string</code>, <code>T=float</code> or <code>T=double</code> are
not valid for mbboDirect records. Signed and unsigned types are equivalent.
</p>

<a name="longin"></a>
<h3>Long Input</h3>
<pre>
 record(longin, "$(NAME)") {
  field (DTYP, "regDev")
  field (INP,  "@$(DEVICE):$(OFFSET) T=$(T)")
  field (SCAN, "I/O Intr")
 }
</pre>
<p>
Default type is <code>T=int16</code>.
</p>
<p>
The register is read to <code>VAL</code>. If the type has less than 32
bits, the value is zero extended or sign extended depending on the
signedness of the type.
</p>
<p>
<code>T=string</code>, <code>T=float</code> or <code>T=double</code> are
not valid for longin records.
</p>

<a name="longout"></a>
<h3>Long Output</h3>
<pre>
 record(longout, "$(NAME)") {
  field (DTYP, "regDev")
  field (OUT,  "@$(DEVICE):$(OFFSET) T=$(T)")
  field (PINI, "YES")
 }
</pre>
<p>
Default type is <code>T=int16</code>.
</p>
<p>
Depending on <code>T</code>, the least significant 8, 16, or 32 bytes
of <code>VAL</code> are written to the register.
</p>
<p>
<code>T=string</code>, <code>T=float</code> or <code>T=double</code> are
not valid for longout records.
</p>

<a name="stringin"></a>
<h3>String Input</h3>
<pre>
 record(stringin, "$(NAME)") {
  field (DTYP, "regDev")
  field (INP,  "@$(DEVICE):$(OFFSET) L=$(LENGTH)")
  field (SCAN, "I/O Intr")
 }
</pre>
<p>
Default and only valid type is <code>T=string</code>.
Default length is <code>L=40</code>.
</p>
<p>
<code>L</code> bytes are read from the register to <code>VAL</code> and
null terminated. Thus, the effective string length is maximal
<code>L</code>-1 bytes.
</p>

<a name="stringout"></a>
<h3>String Output</h3>
<pre>
 record(stringout, "$(NAME)") {
  field (DTYP, "regDev")
  field (OUT,  "@$(DEVICE):$(OFFSET) L=$(LENGTH)")
  field (PINI, "YES")
 }
</pre>
<p>
Default and only valid type is <code>T=string</code>.
Default length is <code>L=40</code>.
</p>
<p>
<code>L</code> bytes are written from <code>VAL</code> to the register.
If the actual string length of <code>VAL</code> is shorter than
<code>L</code>, the remaining space is filled with null bytes. If
it is longer than <code>L</code>, the string is truncated and not
null terminated
</p>

<a name="waveform"></a>
<h3>Waveform Input</h3>
<pre>
 record(waveform, "$(NAME)") {
  field (DTYP, "regDev")
  field (INP,  "@$(DEVICE):$(OFFSET)")
  field (SCAN, "I/O Intr")
  field (NELM, "$(NUMBER_OF_ELEMENTS)")
  field (FTVL, "$(DATATYPE)")
 }
</pre>
<p>
<code>NELM</code> elements are read from the register to <code>VAL</code>.
</p>
<p>
The default type depends on <code>FTVL</code>. For example
<code>FTVL=LONG</code> results in <code>T=INT32</code>.
<code>T</code> and <code>FTVL</code> must match but can differ
in signedness. In most cases, better just specify <code>FTVL</code> and
leave <code>T</code> to the default.
</p>
<p>
If <code>T=string</code>, <code>FTVL</code> must be <code>"CHAR"</code> or
<code>"UCHAR"</code>. <code>L=<i>length</i></code> can be specified but
defaults to and must not exceed <code>NELM</code>.
If <code>L</code> is less than <code>NELM</code>, the
remaining elements are left untouched.
</p>
<p>
<code>FTVL="string"</code> is not supported.
</p>

<a name="calcout"></a>
<h3>Calculation Output</h3>
<pre>
 record(calcout, "$(NAME)") {
  field (DTYP, "regDev")
  field (OUT,  "@$(DEVICE):$(OFFSET) T=$(T) L=$(L) H=$(H)")
  field (PINI, "YES")
 }
</pre>
<p>
Default type is <code>T=int16</code>.
Defaults for <code>L</code> and <code>H</code> depend
on <code>T</code> (see table <a href="#type">above</a>).
</p>
<p>
<code>OVAL</code> (the result of <code>CALC</code> or <code>OCAL</code>,
depending on <code>DOPT</code>) is written to the register. If
<code>T</code> is an integer type, the value is truncated to an
integer and compared to <code>L</code> and <code>H</code>.
If <code>OVAL</code> is lower than <code>L</code> or higher than
<code>H</code>, it is truncated to the nearest limit. 
</p>
<p>
If <code>T=float</code> or <code>T=double</code>,
<code>OVAL</code> is written to the register directly without any
conversion.
</p>
<p>
<code>T=string</code> is not valid for calcout records.
</p>
<p>
To use this device support with calcout records, you need EPICS R3.14.
</p>

<a name="driver"></a>
<h2>Driver Functions</h2>
<h3>Registration</h3>
<p>
A driver must implement the API functions it wants to support and
fill the function pointers into a <code>regDevSupport</code> structure.
It contains the functions <code>report</code>, <code>getInScanPvt</code>,
<code>getOutScanPvt</code>, <code>read</code>, and <code>write</code>.
Write <code>NULL</code> for any API function that is not implemented by
the driver.
The support structure can be global and static like this:
</p>
<p class="indent">
<pre>
static regDevSupport support = {
    report,
    getInScanPvt,
    getOutScanPvt,
    read,
    write
};
</pre>
</p>
<p>
Each configured device must be registered with the following function:
</p>
<p class="indent">
<code>
int&nbsp;regDevRegisterDevice (const&nbsp;char*&nbsp;devicename,
    const&nbsp;regDevSupport*&nbsp;support,
    regDevice*&nbsp;device);
</code>
</p>
<p>
The <code>devicename</code> must be unique on the IOC and is used in the
record links to reference the device.
The <code>support</code> parameter is a pointer to the
<code>regDevSupport</code> structure of this driver.
The last parameter <code>driver</code> is a pointer to a driver private
<code>regDevice</code> structure.
It will be passed as a device handle to any API function.
The driver can freely define <code>struct&nbsp;regDevice</code> and put
in any information it needs to operate one device.
</p>
<h3>API functions</h3>
<p>
The driver can assume that all API functions are called in a thread save
context.
That means it will never happen that two API functions are called for the
same device at the same time.
However, API functions for different devices may be called at the same
time.
</p>
<p class="indent">
<code>
void&nbsp;report (regDevice*&nbsp;<em>device</em>,
    int&nbsp;<em>level</em>);
</code>
</p>
<p class="indent">
<code>
IOSCANPVT&nbsp;getInScanPvt (regDevice*&nbsp;<em>device</em>,
    unsigned&nbsp;int&nbsp;<em>offset</em>);
</code>
</p>
<p class="indent">
<code>
IOSCANPVT&nbsp;getOutScanPvt (regDevice*&nbsp;<em>device</em>,
    unsigned&nbsp;int&nbsp;<em>offset</em>);
</code>
</p>
<p class="indent">
<code>
int&nbsp;read (regDevice*&nbsp;<em>device</em>,
    unsigned&nbsp;int&nbsp;<em>offset</em>,
    unsigned&nbsp;int&nbsp;<em>datalength</em>,
    unsigned&nbsp;int&nbsp;<em>nelem</em>,
    void*&nbsp;<em>pdata</em>,
    int&nbsp;<em>priority</em>);
</code>
</p>
<p class="indent">
<code>
int&nbsp; write (regDevice*&nbsp;<em>device</em>,
    unsigned&nbsp;int&nbsp;<em>offset</em>,
    unsigned&nbsp;int&nbsp;<em>datalength</em>,
    unsigned&nbsp;int&nbsp;<em>nelem</em>,
    void*&nbsp;<em>pdata</em>,
    void*&nbsp;<em>pmask</em>,
    int&nbsp;<em>priority</em>);
</code>
</p>

<ul>
<li>
<code><em>offset</em></code> is the address offset of the register
relative to the beginning to the register block.
</li>
<li>
<code><em>datalength</em></code> is the length of the register in bytes
(one element in case of arrays).
</li>
<li>
<code><em>nelem</em></code> is the number of elements in an array.
</li>
<li>
<code><em>pdata</em></code> is a pointer to a buffer of
<code><em>nelem</em></code>*<code><em>dlen</em></code> bytes.
registers values are copied to or from this buffer.
</li>
<li>
<code><em>mask</em></code> is a pointer to a bit mask of
<code><em>datalength</em></code> bytes.
Only those bits are changed where the mask contains 1 bits. All other bits
remain untouched.
</li>
</ul>
<p>
Strings are handled as arrays of characters:
<code><em>datalength</em>=1</code> and <code><em>nelem</em></code> is the
buffer size including space for the terminating null byte.
</p>
<a name="debugging"></a>
<h2>1 Debugging</h2>
<p>
The variable <code>regDevDebug</code> can be set in the startup script or
at any time on the command line to change the amount or debug output.
The following levels are supported:
</p>
<p>
-1:&nbsp;&nbsp;fatal errors only<br>
&nbsp;0:&nbsp;&nbsp;errors only<br>
&nbsp;1:&nbsp;&nbsp;startup messages<br>
&nbsp;2:+ output record processing<br>
&nbsp;3:+ input record processing<br>
&nbsp;4:+ driver calls<br>
&nbsp;5:+ io printout<br>
</p>
<p>
Be careful using level&gt;1 because many messages can introduce
considerable delays which may result in connection losses.
Default level is 0.
</p>
<p>
On vxWorks, <code>regDevDebug</code> can be set with
<code>regDevDebug=<i>level</i></code>
</p>
<p>
In the iocsh use
<code>var regDevDebug <i>level</i></code>
</p>

<hr>
<small>Dirk Zimoch, 2009</small>
</body>
</html>
